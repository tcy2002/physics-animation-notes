# 常微分方程和积分方法
模拟中用到的一阶常微分方程基本形式： $\frac{dx}{dt} = f(x(t), t)$ 

这里 $x(t)$ 表示这里的 $x$ 是与 $t$ 相关的变量，要通过求解这个微分方程来得到。一般而言，无法直接获得解析解，需要用到某些方法来估计。

考虑一个一般场景，空间中存在保守力场 $U(x)$ （比如重力场）和速度阻尼 $D(v)$ ，粒子的初始位置为 $x_0$ ，初始速度为 $v_0$ ，质量为 $m$ ，则其后续的运动满足二阶常微分方程：

$$
\frac{d^2x}{dt^2}=\frac{\partial U(x)-D(\frac{dx}{dt})}{m}
$$

对于二阶常微分方程，一般通过变量替换降阶为一阶常微分方程之后再求解，即：

$$
\begin{cases}
\frac{dx}{dt}=v \\ 
\frac{dv}{dt}=\frac{\partial U(x)-D(v)}{m}
\end{cases}
$$

## 显式欧拉方法

显式欧拉的形式： $x_{n+1}=x_n + hf(x_n, t)$ ，即把当前位置的变化率看作整个时间步长内的变化率，这种方式非常不稳定，只有一阶精度（泰勒展开后的截断误差为 $O(h^2)$ ）。

对于上面的例子，更新方式为：

$$
\begin{cases}
v_{n+1}=v_n+h\frac{\partial U(x_n)-D(v_n)}{m} \\ 
x_{n+1}=x_n+hv_n
\end{cases}
$$

## 隐式欧拉方法

隐式欧拉的形式： $x_{n+1}=x_n + hf(x_{n+1}, t)$ ，即把目标位置的变化率看作整个时间步长内的变化率，也是一阶精度，一般而言 $x_{n+1}$ 很难直接得到，需要求解矩阵方程，比如隐式布料方法，或通过迭代法来求解，比如预报-校正法，从显式形式开始，得到的值逐步替换进去，最后得到比较准确的隐式结果： $\overline{x_{n+1}}=x_n + hf(x_n, t)\rightarrow x_{n+1}=x_n + hf(\overline{x_{n+1}}, t)$ 。


## 半隐式欧拉

由于隐式欧拉需要迭代，所以有一种更方便的方式：用显式方法更新速度，隐式方法更新位置：

$$
\begin{cases}
v_{n+1}=v_n+h\frac{\partial U(x_n)-D(v_n)}{m} \\ 
x_{n+1}=x_n+hv_{n+1}
\end{cases}
$$

这种方法稳定性更好。

## 中点法
相比于显式欧拉和隐式欧拉，中点法不采用两端的斜率，而是用中点的斜率。计算步骤为：先计算欧拉步长，然后反过来估计中点斜率，最后用中点斜率去估计下一步的 $x$ 值。

对于这里降阶后的二阶常微分方程，速度的斜率计算要用到位置，位置的斜率计算要用到速度，所以中点法的更新方式为：

速度的欧拉步长为 $\Delta v=h\frac{\partial U(x_n)-D(v_n)}{m}$ ，速度中点为 $v_{mid}=v_n+\frac{1}{2}\Delta v$ ，位置的欧拉步长为 $\Delta x=hv_n$ ，位置中点为 $x_{mid}=x_n+\frac{1}{2}\Delta x$ ，分别用中点去更新下一步的速度和位置： $v_{n+1}=v_n+h\frac{\partial U(x_{mid})-D(v_{mid})}{m}$ ， $x_{n+1}=x_n+hv_{mid}$ 

## 梯形法

## Runge Kutta方法
RK方法和中点法都类似梯形法，即不止采用某一端的斜率去估计变化率。最常用的是RK4，即采用前后端点+两个中点。对于原本的一阶常微分方程，更新方法为：

$$
\begin{cases}
k_1=f(x_n,t_n) \\ 
k_2=f(x_n+\frac{hk_1}{2},t_n+\frac{h}{2}) \\
k_3=f(x_n+\frac{hk_2}{2},t_n+\frac{h}{2}) \\
k_4=f(x_n+hk_3,t_n+h) \\
x_{n+1}=x_n+\frac{h}{6}(k_1+2k_2+2k_3+k_4)
\end{cases}
$$

这里每一个k就是各个点处的斜率。估计后一个点时，用到了前一个点，目的是为了缩小误差。n阶RK方法具有n阶精度。

对于上面的例子，更新方法为：

$$
\begin{cases}
k_{v1}=\frac{\partial U(x_n)-D(v_n)}{m} \\ 
k_{x1}=v_n \\
k_{v2}=\frac{\partial U(x_n+\frac{hk_{x1}}{2})-D(v_n+\frac{hk_{v1}}{2})}{m} \\
k_{x2}=v_n+\frac{hk_{v1}}{2} \\
k_{v3}=\frac{\partial U(x_n+\frac{hk_{x2}}{2})-D(v_n+\frac{hk_{v2}}{2})}{m} \\
k_{x3}=v_n+\frac{hk_{v2}}{2} \\
k_{v4}=\frac{\partial U(x_n+hk_{x3})-D(v_n+hk_{v3})}{m} \\
k_{x4}=v_n+hk_{v3} \\
v_{n+1}=v_n+\frac{h}{6}(k_{v1}+2k_{v2}+2k_{v3}+k_{v4}) \\
x_{n+1}=x_n+\frac{h}{6}(k_{x1}+2k_{x2}+2k_{x3}+k_{x4})
\end{cases}
$$

同样需要用前一个点来估计后一个点，只不过根据降阶后的方程组，变成了交替更新， $k_{v2}$ 用 $k_{x1}$ 和 $k_{v1}$ 更新， $k_{x2}$ 用 $k_{v1}$ 更新，以此类推。
