# 刚体仿真

本篇刚体笔记主要讲解基于速度（冲量）的求解器，与书籍Stable, Robust, and Versatile Multibody Dynamics Animation方法基本一致，这是很多游戏物理引擎的基础，在实时性和稳定性上有很好的取舍。除此之外，还会介绍一些精度更高或性能更优的求解器比如IPC、AVBD，前者是目前最常用的非侵入式求解器，后者用染色算法把性能做到了极致。

## 刚体物理基础

### 物理属性

刚体的基本物理属性包括：惯性属性、位置和朝向、速度和加速度等。与普通粒子或质点不同，刚体有体积和朝向，除了3个位置自由度外还有3个旋转自由度。对于粒子和质点而言，惯性属性只有质量，而对于刚体，还有一个属性：惯性张量，这是转动惯量在三维空间中的描述，通常用矩阵 $I\in R^{3\times 3}$ 表示，但由于一般刚体的形状大多是对称的，只有对角线非零，所以有时也可简化为用一个三维矢量来储存。

- 惯性张量的物理意义：对于任意方向 $n$ ， $In$ 表示刚体绕轴 $n$ 的转动惯量；刚体的角速度为 $\omega$ ，则刚体的角动量为$I\omega$，角动能为 $\frac{1}{2}\omega^TI\omega$ ，牛顿第二定律的力矩形式（欧拉方程）： $T=I\dot \omega + \omega \times I\omega$ ，后面的 $\omega \times I\omega$ 是描述陀螺效应（进动）的项。

- 惯性张量的性质：特征向量就是物体的主惯性轴，特征值是主转动惯量。并不是所有方向都是主惯性轴，绕主惯性轴旋转不会发生耦合，绕其他轴旋转会发生耦合，导致角速度和角动量不同向，产生进动。

- 对于某些求解器，会把质量和惯性张量一并考虑： $\hat I\in R^{6\times 6}$ ， $\hat I=\left[\begin{matrix} M & 0\\ 0 & I\end{matrix}\right]$ ，其中 $M=mI_3$ ， $\hat I$ 也可看做广义质量矩阵；在某些求解器中，还会进一步将所有刚体的质量属性存成一个大型的稀疏矩阵。

惯性张量矩阵和质量一样，属于已知常量，通常在刚体初始化时定好。一般形状的惯性张量矩阵要通过积分来求，一些常见的对称形状（质量为1、相对于质心）的惯性张量矩阵如下：

- 立方体：长宽高分别为abc， $I=\left[\begin{matrix}\frac{b^2+c^2}{12} & 0 & 0\\0 & \frac{a^2+c^2}{12} & 0\\0 & 0 & \frac{a^2+b^2}{12}\end{matrix}\right]$ 

- 圆柱体：半径r高h， $I=\left[\begin{matrix}\frac{3r^2+h^2}{12} & 0 & 0\\0 & \frac{r^2}{2} & 0\\0 & 0 & \frac{3r^2+h^2}{12}\end{matrix}\right]$ 

- 椭球体：轴向半径分别为abc， $I=\left[\begin{matrix}\frac{1}{5}(b^2+c^2) & 0 & 0\\0 & \frac{1}{5}(a^2+c^2) & 0\\0 & 0 & \frac{1}{5}(a^2+b^2)\end{matrix}\right]$ 

- 胶囊体的精确惯性张量矩阵相对比较复杂，需要分成上下两个半球体和中间的圆柱体，通过组合公式（平行轴定理）计算得到，一般物理引擎则会直接通过胶囊体的包围盒来计算。

- 一般凸多面体：通常也直接用AABB或OBB来算，精确计算方法可参考：[PolyhedralMassProperties.pdf](https://www.geometrictools.com/Documentation/PolyhedralMassProperties.pdf)

- 复合刚体：指一个刚体具有多个sub shape，需要通过组合公式计算整体的惯性张量矩阵。注意不论是单刚体还是复合刚体，所储存的local inertia最好都相对于质心。

### 坐标系统

一般物理引擎的坐标和游戏引擎一样，用Transform来表示。Transform有两部分：Basis和Origin，分别表示旋转量和位移量。Origin是一个三维矢量，Basis可以是一个3x3的旋转矩阵，也可以是四元数，具体看引擎的实际选择，两种各有优劣，直接用旋转矩阵更直观一些，但需要正交化修正，所以可以在integrate步骤中用四元数来更新旋转，其他时候用旋转矩阵来做，比如向量变换和矩阵变换等。

记 $R$ 为Transform.Basis， $T$ 为Transform.Origin，则对任意点$P$的变换为： $p'=Rp+T$ ，对任意矢量 $v$ 的变换为 $v'=Rv$ ，父节点的Transform为 $(R_0,T_0)$ ，子节点的Transform为 $(R_1,T_1)$ ，则经过级联后的子节点Transform为 $(R_0R_1,R_0T_1+T_0)$ 

对于前面相对于质心的local inertia，通过计算可以变换为world inertia： $I_{world}=RI_{local}R^T$ ， $I_{world}^{-1}=(RI_{local}R^T)^{-1}=RI_{local}^{-1}R^T$ ，可以事先计算好local inertia的逆 $I_{local}^{-1}$ 来避免重复计算。一些其他矩阵量的计算也是类似的。

由于储存性能，额外引入的误差等原因，游戏物理引擎中一般不会用到齐次坐标。

### 数学基础

1. 线性方程求解

- 雅可比（Jocabian）矩阵 $J$ ：约束的一阶导矩阵。矢量$x\in R^n$的约束$C$表示为： $f(x)=(\le,\ge) 0$ ，存在若干个这样的约束 $C_1,C_2,...C_m$ ，则雅可比矩阵 $J\in R^{m\times n}$ ：
  $$J=\left[\begin{matrix}
  \frac{\partial f_1}{\partial x_1} & \frac{\partial f_1}{\partial x_2} & ... & \frac{\partial f_1}{\partial x_n} \\
  \frac{\partial f_2}{\partial x_1} & \frac{\partial f_2}{\partial x_2} & ... & \frac{\partial f_2}{\partial x_n} \\
  \vdots & \vdots & \ddots & \vdots \\
  \frac{\partial f_m}{\partial x_1} & \frac{\partial f_m}{\partial x_2} & ... & \frac{\partial f_m}{\partial x_n}
  \end{matrix}\right]$$
  类似的还有海森（Hessian）矩阵：约束的二阶导矩阵，但与雅可比矩阵不同的是，每个约束都有一个自己的海森矩阵：
  $$H_i=\left[\begin{matrix}
  \frac{\partial^2 f_i}{{\partial x_1}^2} & \frac{\partial^2 f_i}{\partial x_1\partial x_2} & ... & \frac{\partial^2 f_i}{\partial x_1\partial x_n} \\
  \frac{\partial^2 f_i}{\partial x_1\partial x_2} & \frac{\partial^2 f_i}{{\partial x_2}^2} & ... & \frac{\partial^2 f_i}{\partial x_2\partial x_n} \\
  \vdots & \vdots & \ddots & \vdots \\
  \frac{\partial^2 f_i}{\partial x_1\partial x_n} & \frac{\partial^2 f_i}{\partial x_2\partial x_n} & ... & \frac{\partial^2 f_i}{{\partial x_n}^2}
  \end{matrix}\right]$$
  雅可比矩阵描述了各个位置的约束梯度，海森矩阵则描述的是各个位置的约束曲率。
- 雅可比迭代、Gauss-Seidel迭代、PGS：参考[MathUtils](https://github.com/tcy2002/physics-animation-notes/blob/main/MathUtils.md)

2. 非线性优化问题
这部分内容是IPC、原始对偶等方法的基础，如果只看基于速度（冲量）的部分可以跳过。

- 序列二次规划（SQP）：将复杂非线性约束问题拆分成一系列简单的二次规划子问题，并且把约束近似为线性函数，解QP子问题得到下一步的搜索方向。
  直观例子：
    - 目标：找到圆 $x^2+y^2=1$ 上距离 $(2,2)$ 最近的点
    - 建模：
        - 目标:  $\text{argmin}_{x,y}(x-2)^2+(y-2)^2$ ，非线性二次函数
        - 约束:  $x^2+y^2-1=0$ ，非线性等式约束
    - 思路：目标函数二次化，约束线性化
    - 迭代过程：从点 $(1,0)$ 开始，此处在约束圆上的切线是 $x=1$ ，所以这一步变成了在直线 $x=1$ 上找距离 $(2,2)$ 最近的点，得到 $(1,2)$ ，然后修正到圆上得到 $(\frac{\sqrt{5}}{5},\frac{2\sqrt{5}}{5})$ ，继续下一次迭代
    - 分析：把圆上找点优化为切线上找点就是约束线性化；在直线 $x=1$ 上找距 $(2,2)$ 最近的点时，可以理解为将 $x=1$ 代入约束方程，得到一个降次后的关于 $y$ 的方程，然后通过 $y=0$ 附近的梯度（雅可比矩阵）和曲率（海森矩阵）构建二次方程，找到最低的位置作为新的位置，实际上这里的目标方程就是二次方程，所以所构建的二次方程和原本的目标方程是完全贴合的。约束线性化的目的：降维，目标函数二次化的目的：方便找最低点
- 牛顿法和拟牛顿法：牛顿法利用二阶导（海森矩阵）来寻找搜索方向，拟牛顿法不直接计算海森矩阵，利用历次迭代的梯度变化估算海森矩阵
  仍然用上面的例子：
    - 构造拉格朗日： $L(x,y,\lambda)=(x-2)^2+(y-2)^2+\lambda\cdot(x^2+y^2-1)$
    - 目标：找到一组 $(x,y,\lambda)$ ，使得$L$的梯度全为0，即找到了 $L$ 的极值点位置（KKT条件）
    - 牛顿法迭代过程：从点 $(1,0)$ 、 $\lambda=0$ 开始，发现梯度方程的结果不为0（残差），那么计算曲率（海森矩阵），用海森矩阵的逆和残差值算出跳跃步长 $(\Delta x,\Delta y, \Delta\lambda)$ ，得到下一个点。牛顿法收敛很快，因为是根据全量海森矩阵计算的步长。
    - 拟牛顿法迭代过程：并不在每一步都计算全量的海森矩阵，而是从单位矩阵 $H_0=I$ 开始，根据前后步骤的梯度变化更新曲率的值。拟牛顿法比牛顿法收敛慢一点，但比纯梯度法快得多。 
    - 与PGS类似，也有投影牛顿法，即获得新的迭代结果后，须投影到约束可行域内，如旋转正交性修正等。
- 内点法：包括障碍函数和原始-对偶方法，原本是用于处理非线性规划（NLP）的方法，但可扩展到凸非线性优化中。
    - 障碍函数：相比于单纯形法在边界上行走，内点法通过边界施加斥力保持在可行域内取点，无法真正碰到边界
        - 目标： $\min c^T x$ 
        - 约束： $Ax\ge b,x\ge 0$ 
        - 构造带惩罚的目标： $\min c^T x-\mu\sum _{i=1}^n \ln(x_i)$ ，转换为平滑无约束问题
    - 迭代过程：设定一个较大的障碍参数$\mu$，用牛顿法解出极小值点，然后逐步减小$\mu$，边界的斥力逐渐减小，向真实问题的最优解靠近。
    - 原始-对偶法：直接使用障碍函数有一个问题：当$x$很小时， $-\ln x$ 的倒数变得很大，导致海森矩阵奇异化，难以精确求解。
        - 对偶目标： $\max b^T y$ 
        - 约束： $A^T y+s=c,y\ge 0$ ， $y$ 是对偶变量， $s$ 是松弛变量
        - 解KKT条件来逐步逼近最优解：
            - $Ax-b=0$ 原问题约束
            - $A^T \lambda +s-c=0$ 对偶问题约束，含松弛变量
            - $XSe-\epsilon e=0$ 互补松弛性，隐含了障碍函数的导数
        - 在原始对偶法中，虽然$x$和$s$也会趋于0，但综合考虑原问题和对偶问题约束条件时，数值稳定性要优于直接求障碍函数导数，可以比较准确地预测$x$和$s$的变化方向。

### 积分方法

包括欧拉、中点法、Runge-Kuta、Verlet积分等，参考[ODE](https://github.com/tcy2002/physics-animation-notes/blob/main/ODE.md). 游戏引擎一般用半隐式欧拉即可，不需要更高的精度。

### 动力学过程

不同的刚体物理教程对动力学过程有不同的表现形式，最简单直接的为：
  $$M\ddot x=f$$
即牛顿第二定律，对于刚体系统而言，这里的 $f$ 和 $M$ 分别为广义力和广义质量矩阵。某些地方还会考虑非惯性系的情况，比如旋转的球体表面、旋转的机械臂抓取物体的过程，会引入一个额外项 $C(x,\dot x)$ 来表示科里奥利力和向心力：
  $$M\ddot x+C(x,\dot x)=f$$
对于只有保守力场（比如重力场）的惯性系而言可以不用考虑。

前面的积分方法是从运动学视角来看，而动力学过程则是动力学视角，二者需要综合来看，动力学过程中的力 $f$ 为积分中的二阶项（加速度）$\ddot x = a(t)$ 提供了来源。

对于弹簧质点模型等简单的平滑模型而言，结合积分方法和动力学过程的仿真算法直观而简明，且不论是使用矩阵计算还是线性迭代，都具有良好的可控性和优化空间。然而，刚体的各类约束有较多的非线性和非平滑成分，所以产生了各类有不同取舍的方法。

## 基本碰撞求解

### 整体计算流程

从一个简单的例子来看：给定两个刚体，蓝色为刚体A，红色为刚体B，某一时刻发生重叠：

![2rigids](./blobs/2rigids.png)

刚体物理引擎大体上按照两个模块进行仿真求解：Collision Detection和Simulation.

- CollisionDetection：碰撞检测阶段包括
  - BroadPhase使用一些空间加速方案粗略查询有哪些可能发生相互重叠的碰撞对；
  - NarrowPhase求出刚体对的接触信息（Contact Manifold）：接触点位置、接触点法矢量、侵入距离（Penetration），一般会选择其中一个刚体作为参考，比如图中用刚体A表面的作为接触点，用刚体A表面的法矢量作为接触法矢量，侵入距离为图中虚线长度。
  
  CollisionDetection目前的算法比较固定，BroadPhase不同引擎会有不同的空间加速方案比如HashGrid或动态AABB树等，但NarrowPhase基本就是SAT或GJK+EPA，也会有一些优化方案比如复用前一帧的分离轴。当侵入距离过大时，可能会发生穿透，这在时间步长较长，两帧之间刚体移动距离较大的情况下时有发生，因此产生了CCD碰撞检测（连续性碰撞检测），通过substep、射线扫描等方式防止穿透发生。

- Simulation：基于CollisionDetection阶段得到的碰撞信息，对刚体的运动进行约束，使之满足基本的运动和接触规则。根据不同需求和场景，会有很多不同的求解器实现方法，下面的求解器是基于速度（冲量）的基础方法。

### 碰撞约束求解

下图中有4个刚体，共4x6=24个位置自由度，即有24个未知量需要求解，由于碰撞约束的亏秩性，把位置作为未知量来看是没有唯一精确解的，但可以求向着满足约束方向演化的未知量变化量，也就是速度。对速度进行约束，是通过向刚体施加冲量来实现的，然后通过误差修正项从约束被破坏的状态中恢复。

![4rigids](./blobs/4rigids.png)

碰撞约束的非平滑因素主要体现在LCP问题（Linear Complementary Problem）和库伦摩擦上。LCP描述的是刚体的某些运动特征和约束有互补关系，比如当刚体之间有接触时，法向排斥不为0，没有接触时，法向排斥为0，这种关系用数学形式表示为： $z\ge 0; w\ge 0; z^Tw=0$ ；库伦摩擦则是几乎所有物理引擎会用到的描述摩擦约束的模型，要满足 $|f_t|\le \mu f_n$ ，摩擦数值的变化在切向上呈现“Z”字形。

对于这种非平滑因素，各种求解器有各种不同的处理方式。对于碰撞约束而言，碰撞检测阶段筛选出了发生相互侵入的刚体，这一步已经体现了LCP问题的一半，另一半通过约束速度来实现即可。通常在游戏引擎内会偏向性能侧的考虑，会尽量降低整体约束计算的复杂性，常用方式是通过逐个求解每个约束，然后多次迭代使得整体趋于收敛，类似PGS迭代，这种方式也是PBD的实现基础。

回到前面那张两个刚体简单接触的图，接下来用直观的形式详细推导一下碰撞约束求解的过程：

![2rigids](./blobs/2rigids.png)

**1. 约束公式推导**

如前所属，考虑对速度进行约束，约束条件为两个刚体在相互接触的法向上不能发生相互侵入，即法向上的相对速度要在分离方向上大于等于0：
  $$n\cdot(v_b+\omega_b\times r_b-v_a-\omega_a\times r_a)\ge 0$$
令 $J_{ab}=\left[\begin{matrix}-n \\-r_a\times n \\n \\r_b\times n\end{matrix}\right]^T$，$u=\left[\begin{matrix}v_a \\\omega_a \\v_b \\\omega_b\end{matrix}\right]$ ，（广义速度），则上面的式子可以写为： $J_{ab} u\ge 0$ ，这里对LCP问题的处理方式是，当碰撞检测的结果里出现了这对刚体，说明这对刚体有相互碰撞， $J_{ab} u < 0$ ，通过正的 $\Delta u$ （指$\Delta u \cdot n>0$）将其约束到
  $$J_{ab}(u+\Delta u)= 0 \tag{1}$$
的分离状态即可；如果碰撞检测后没有这对刚体，说明没有发生碰撞， $J_{ab} u \ge 0$，那么$\Delta u$ 就为0.

这里的 $J_{ab}$ 正是描述整个刚体约束系统的雅可比矩阵的关于a和b碰撞的这一行（该行的其他维度都补充为0）。雅可比矩阵是从位置约束本身出发，再次说明速度作为位置的一阶导，用于求解约束是合理的。

**2. 约束求解过程**

由于梯度方向变化率最大，可以将 $\Delta u$ 的方向固定在梯度方向上，这里的梯度方向就是 $J_{ab}$ 所描述的方向。另外，根据牛顿第一定律，相互作用的刚体产生的相互作用力相同，因此令 $F_{ab}=J_{ab}^T\lambda$ ，那么两个刚体的速度变化量就为
  $$\Delta u = \Delta tM^{-1}F_{ab} = \Delta t M^{-1}J_{ab}^T\lambda$$
其中$M$是这两个刚体的广义质量矩阵： $M=\left[\begin{matrix}\hat I_a & 0 \\0 & \hat I_b\end{matrix}\right]=\left[\begin{matrix}m_a I_3 & 0 & 0 & 0 \\0 & I_a & 0 & 0 \\0 & 0 & m_b I_3 & 0 \\0 & 0 & 0 & I_b\end{matrix}\right]$ ， $I_3$ 是三阶单位矩阵， $I_a$ 和 $I_b$ 分别是刚体a和b在世界坐标系下的惯性张量矩阵。

把 $\Delta u$ 代入到式子 $(1)$ 中可以得到： $J_{ab} M^{-1}J_{ab}^T\lambda=-J_{ab}u$ ，这里 $\Delta t$ 被吸收进 $\lambda$ 里了，由于直接求解会有jitter（表现为刚体上下抖动，上一帧有碰撞下一帧没碰撞，反复横跳），所以在右侧加上一个bias项：
  $$J_{ab} M^{-1}J_{ab}^T\lambda=-J_{ab}u+b$$
这个式子就是经典的基于冲量（速度）的碰撞约束求解公式。实际计算时bias项是一个与误差修正有关的项，后面会提到。求得 $\lambda=\frac{-J_{ab}u+b}{J_{ab} M^{-1}J_{ab}^T}$ 之后，根据上面求出 $J_{ab}^T\lambda$ 即可得到约束冲量。由于 $M^{-1}$ 是一个不变的质量属性矩阵，所以可以事先计算得到，不需要每次计算时求逆。

**3. 恢复系数与误差修正**

实际模拟中，刚体碰撞后的分离情况由恢复系数 $r$ 决定，恢复系数为1时为完全弹性碰撞，恢复系数为0时为完全塑性碰撞。因此，在计算法向碰撞约束时， $J_{ab} u$应为$J_{ab} u(1+r)$ . 另外，为避免已经发生的侵入不可恢复，可以增加与侵入距离有关的bias项，计算方法为侵入距离乘以一定的比例系数再除以时间步长。这里的侵入距离就是碰撞约束的误差修正项。

**4. Sequential Impulse**

上面是两个刚体碰撞的简单情况，当系统中有多个刚体相互碰撞时，可以用Projected Gauss-Seidel（PGS）方法来逐个求解每对碰撞约束，多次迭代后收敛到相对稳定的目标状态，这就是Bullet和PhysX采用的Sequential Impulse. 为什么是PGS？其实上面的式子 $J_{ab} M^{-1}J_{ab}^T\lambda=-J_{ab}u+b$ 可以看作一个描述系统整体的大型矩阵方程 $Ax=b$ 中与ab碰撞有关的一部分，逐个求解每对碰撞约束就类似于上面的迭代求解过程，这和PBD非常像，只是在处理约束的方式上有所不同。要注意的是，PGS本身并不是完全适配LCP问题，但借助Sleep机制能获得相对稳定的接触效果，在性能与稳定性上做到平衡。

传统的Sequential Impulse迭代过程中，并非直接修改刚体的速度，而是另外储存刚体经过每次迭代后的临时速度，迭代结束后将总冲量一次性赋给所有刚体，这种方式的缺点是每次迭代采用了同一套接触信息（Contact Manifold），在场景规模大，自由度极高的情况下收敛较慢，因此产生了Substep方法，可通过一定的方式动态更新每次迭代时所采用的接触信息，从而加快收敛效率。

另外，这种Sequential Impulse方法要求每次必须按照顺序逐个处理每个约束，因为PGS中前面计算得到的值会马上用到后面的计算中，所以无法很好的并行化处理。可采用染色法将约束分组，不同组别的刚体之间没有约束关联，那么每个组之间都能并行计算。ABVD通过改进的染色方法，可实现GPU高度并行化。

**5. 积分方法**

PhysX等引擎采用的是半隐式欧拉，根据上面求出的 $\Delta u$ 更新速度是显式欧拉，用更新之后的速度更新位置是隐式欧拉，对于游戏需求而言已经可以获得较好的稳定性了，无需使用更高阶的积分方法。

**6. 其他问题**

- 进动项问题
  
  可能会有疑问：为什么前面的推导过程没体现牛顿-欧拉方程里的进动项 $\omega\times I\omega$ ？因为产生进动项的本质原因是惯性张量 $I$ 在随时间变化，所以对角动量取微分 $d(I\omega)$ 时产生了进动项，而上面的求解过程所采用的是瞬时冲量，因此将 $I$ 视为常量。

- 与基于力的约束的关系

  在[Constraint.md](./Constraint.md)中介绍了基于力的约束模型，对比一下两种方法的约束公式：
  $$JWJ^T\lambda=-JWQ-\dot J\dot q \tag a$$
  $$J_{ab} M^{-1}J_{ab}^T\lambda=-J_{ab}u+b \tag b$$
  前者从单个物体的位置的视角出发，求解满足当前约束条件的约束力，然后通过积分方法来更新位置和速度（这里需要考虑欧拉方程的进动项了）；后者从两个物体的相对速度视角出发，求解满足当前约束所需的校正冲量。
  实际上，令 $q=\left[\begin{matrix}P_a \\r_a \\P_b \\r_b\end{matrix}\right]$ ，$J_{ab}$不变，则位置约束为：
  $$\dot C(q)=\frac{\partial C}{\partial q}\cdot \dot q = J_{ab}\dot q=0 \tag c$$
  $$\ddot C(q)=\frac{\partial \dot C}{\partial q}\cdot \dot q + \frac{\partial C}{\partial q}\cdot \ddot q=\dot J_{ab}\dot q + J_{ab}\ddot q = 0 \tag d$$
  式(d)中的 $\frac{\partial \dot C}{\partial q}\cdot \dot q$ 在前面的推导过程中被忽略了。另外，式(b)中 $J_{ab}u$ 是需要校正的相对速度，式(a)中 $JWQ$ 是外力作用下约束方向上的速度变化量，在形式上是类似的。
  

## 各类约束求解

基本碰撞约束（Contact Constraint）是刚体物理中各类约束的一种，除此之外还有摩擦约束、距离约束、球铰约束、合页约束、滑轨约束、自定义自由度约束等。通常碰撞约束和摩擦约束会放在一起求解，因为约束形式和所使用的数据是一致的，不同之处在于碰撞约束在法向，而摩擦约束在切向。对于各类不同的约束形式，都可以按照和上面类似的方式，从约束方程、梯度方向入手，推导出计算公式，然后按照同样的Sequential Impulse框架来求解。

各类约束效果（从左到右依次为球铰约束、滑轨约束、合页约束）：

![constraints_gif](./blobs/constraints.gif)

### 摩擦约束

摩擦约束与碰撞约束的形式是类似的，同样考虑等式约束： $J_{ab}(u+\Delta u)= 0$ ，只不过这里选择相互垂直切向方向而不是法向$n$，并且没有LCP问题，但是需要按照标准PGS和库伦定律把求解过程中的摩擦力 $|F_{ab}^{f}|$ 约束到 $\mu|F_{ab}|$ 内。对于切向方向的选择，通常是选两个相互垂直的方向 $t_1$ 和 $t_2$ ，在这两个方向上都做约束，或者选择相对速度在切平面上的投影方向。剩余步骤与碰撞约束相同。在Sequential Impulse的迭代过程中，冲量是不断多次施加的，因此需要计算法向施加的总冲量，然后把切向的总冲量按照库伦定律进行约束。

### 球铰约束（Ball-in-Socket Joint / Point-to-Point Joint）

![ball-in-socket](./blobs/ball-in-socket.png)

球铰约束的条件为：两个刚体上各有一个相对于自身的锚点（Anchor），相对于各自质心 $P_a$ 和 $P_b$ 的位置分别为 $r_a$ 和 $r_b$ ，这两个锚点在模拟中保持位置重合。同样考虑速度约束，约束形式为： $v_b+\omega_b\times r_b-v_a-\omega_a\times r_a=0$ （即去掉了碰撞约束中与法向有关的部分），仍然令 $J_{ab}=\left[\begin{matrix}-I_3 \\r_a^\times \\I_3 \\-r_b^\times\end{matrix}\right]^T$，$u=\left[\begin{matrix}v_a \\\omega_a \\v_b \\\omega_b\end{matrix}\right]$ ，约束公式为： $J_{ab} M^{-1}J_{ab}^T\lambda=-J_{ab}u+b$ ，接下来的求解过程就与碰撞约束没有区别了。球铰约束的误差修正项为两个锚点的实际距离。

为什么这里的 $J_{ab}$ 维度是 $3\times 12$ 而不是和前面一样的 $1\times 12$ ？因为球铰约束有三个自由度，将三个自由度分开些的形式为 $e_i \cdot (v_b+\omega_b\times r_b-v_a-\omega_a\times r_a)=0$ ， $e_i$ 是轴向单位矢量 $e_x,e_y,e_z$ 

### 距离约束（Distance Joint）

距离约束的条件为：两个刚体上锚点之间的距离不超过指定值，或者始终等于指定值。如果是前者，相当于将锚点用固定长度的绳子连接起来，约束公式与球铰约束相同，但不同的是，“不超过”条件带来了不等式约束和LCP问题，处理方式也与碰撞约束类似，只需判断距离是否超过指定值，超过则需要进行约束，误差修正项为超过的距离，与碰撞约束的侵入深度类似。如果是后者，则按照与前面球铰约束类似的方式处理等式约束即可，这里只对相互方向上的一个自由度做约束，误差修正项为偏离指定距离的长度

### 合页约束（Hinge Joint）

![hinge](./blobs/hinge.jpg)

相比球铰约束可以任意角度自由转动，合页约束只允许在一个相对平面内转动，比如人的膝关节，因此约束条件除了锚点重合外，还需要旋转轴平行。锚点重合的约束形式与上面相同，旋转轴平行的约束形式为：以其中一个刚体的旋转轴比如 $n_a$ 作为参照，将另一个刚体的旋转轴约束到平行方向上，实现方式为：选择垂直于 $n_a$ 并且相互垂直的两个方向 $t_1$ 和 $t_2$ ，要求刚体的角速度在这两个方向上的投影相等，即： $(\omega_a - \omega_b) \cdot t_i = 0$ ，如此以来两个刚体在除旋转轴方向上的其他旋转都是同步的。令 $J_{ab\_\omega}=\left[\begin{matrix}t_i \\-t_i\end{matrix}\right]^T$ ， $\omega=\left[\begin{matrix}\omega_a \\\omega_b\end{matrix}\right]$，$M_\omega=\left[\begin{matrix}I_a & 0 \\0 & I_b\end{matrix}\right]$ ，约束公式为： $J_{ab\_\omega} M_\omega^{-1}J_{ab\_\omega}^T\lambda_\omega=-J_{ab\_\omega}\omega + b$ ，误差修正项为两个旋转轴的实际偏差，即 $n_a\times n_b \cdot t_i$ 

### 滑轨约束（Slider Joint）

![slider](./blobs/slider.jpg)

滑轨约束的条件为：一个刚体只能沿着一条相对另一个刚体固定的轴向移动。

角度约束：两个刚体的角速度必须完全一致，即： $I_3(\omega_a - \omega_b) = 0$ ， $J_{ab\_\omega}=\left[\begin{matrix}I_3 \\-I_3\end{matrix}\right]^T$，$\omega=\left[\begin{matrix}\omega_a \\\omega_b\end{matrix}\right]$ ，约束公式为： $J_{ab\_\omega} M_\omega^{-1}J_{ab\_\omega}^T\lambda_\omega=-J_{ab\_\omega}\omega + b$ ，误差修正项为角速度的差.

轴向位置约束：以轴 $n$ 为参考，刚体不能在切向 $t_1$ 和 $t_2$ 上发生相对位移： $t_i \cdot (v_b+\omega_b\times r_b-v_a-\omega_a\times r_a)=0$ ， $J_{ab}=\left[\begin{matrix}-t_i \\
-r_a \times t_i \\t_i \\r_b \times t_i\end{matrix}\right]^T$，$u=\left[\begin{matrix}v_a \\\omega_a \\v_b \\\omega_b\end{matrix}\right]$ ，约束公式为 $J_{ab} M^{-1}J_{ab}^T\lambda=-J_{ab}u + b$ ，误差修正项为切向$t_i$上偏离的距离。

### 自定义自由度约束（6-DOF Joint）

自定义自由度约束是物理引擎的一个重要功能点，可以让用户指定两个刚体之间有哪些约束。前述约束都是某些自由度的组合形式。为什么不直接使用自定义自由度约束？因为前面推导的计算方法在过程上有所简化。常规方法是：有哪些自由度受限，就在哪些自由度上进行约束，推导相应的雅可比项和误差修正项，然后对每个约束逐个施加impulse. 比如经典的万向节约束（Universal Joint）有两个旋转自由度，相比于合页，只需要在一个方向上做旋转约束；“玻璃擦”约束有两个位置自由度，相比于滑轨，也只需要在一个方向上做位置约束。位置自由度的约束方法为：保持刚体b相对于刚体a在自由度方向上的相对位置不变，旋转自由度的约束方法为：保持刚体b相对刚体a的滚转、俯仰、偏航角不变。当存在LCP问题，比如合页旋转角度有限制，锚点之间距离有限制时，可以用类似处理碰撞的方法。

## 关节体仿真

基于约束的关节体仿真通过封装以上各类约束来实现。

### 关节驱动

关节驱动通常的实现方式为：设置一个目标角度或目标角速度，控制关节朝向预期的目标转动。对上面的方法而言，这是很直观和容易实现的，设置目标角速度即增加一个绕旋转轴 $n$ 的约束 $(\omega_b - \omega_a) \cdot n = \omega_{target}$ ，设置目标角度即增加一个类似位置约束的角度约束，误差修正项为当前角度到目标角度的差值。除对关节施加约束外，还可直接对连接的刚体施加大小相等，方向相反的扭矩。

### Ragdoll

Ragdoll是物理角色动画的一种，用于实时地、符合物理规律地模拟一个角色在失去控制之后（通常是死亡倒下）的角色运动，角色完全基于物理引擎实现，一般是刚体+关节约束，也有可能涉及软体。若需要主动驱动的Ragdoll，可以采用上面的约束驱动方法，也可采用类似机器人控制的方法比如PD/PID，或者与关键帧动画和IK混合使用。

## 其他求解方法

### PBD/XPBD

上面的方法是基于速度（冲量）的约束，而PBD/XPBD是直接对位置进行约束，大致步骤：
遍历每个约束：
- 根据当前位置和速度、加速度预测下一帧位置、速度
- 预测的下一帧位置往往会破坏约束条件，因此需要修正
    - PBD：把位置约束看作完全刚性，将相互约束的两个刚体直接拉到不破坏约束的位置上，缺点：迭代次数影响仿真效果（迭代次数越多刚性程度越大）
    - XPBD：与PBD类似，但额外增加拉格朗日乘子项，将绝对刚性约束放松为类似弹性的约束，可解决上述问题
- 用约束后的位置反过来更新速度
同样通过多次迭代、逐个处理约束，收敛到全局最优解附近。

### Featherstone's Rigidbody Dynamics

级联关节体动力学，这里不提

### IPC, Primal-Dual

1. IPC：Incremental Potential Contact，增量势能接触模型：
  $$x^{t+1}=\text{argmin}_x E_d(x,x^t,v^t)+B(x,\hat d)+D(x,\hat d)$$
- 增量势能 $E_d$ 保证动力学合理性：让运动符合惯性、动量等物理规律
    - 增量势能最小化本质是牛顿-欧拉动力学方程的数值离散形式（能量变分原理），“力与运动的平衡”等价于“能量极小化”
- 障碍势能 $B$ 保证几何约束：避免物体穿透，原理与内点法相似
- 摩擦势能 $D$ 保证 “接触力学合理性”：模拟接触面的摩擦阻力，消耗相对运动的能量。
IPC的迭代过程：
- ①通过牛顿迭代求解更新方向（参考前文的海森矩阵、牛顿迭代）
- ②由于给出更新步长 $\Delta p$ 可能过大，导致刚体轨迹中出现穿透，因此须结合连续性碰撞检测（CCD）验证轨迹，逐步调整步长为 $\alpha \Delta p$ 
- ③收敛判断：若更新步长小于阈值，重新计算的接触信息中接触点距离均 $\ge 0$ ，则终止迭代，否则回到①

2. Primal-Dual，原始对偶内点法
  $$min _{v} max _{r} \frac{1}{2}(v-\overline{v})^{\top} M(v-\overline{v}) +\overline{U}(v) -v^{\top} H^{\top} r+\kappa \sum_{i} log \left(-b_{i}(r)\right)$$
- 约束松弛：将法向、摩擦约束用障碍函数转化为无约束优化问题
- KKT系统：对松弛后的目标函数求导，得到一阶最优条件，形成包括原始变量（刚体位置）和对偶变量（拉格朗日乘子$\lambda$）的KKT系统
- 用牛顿迭代求解KKT系统，逐步减小障碍参数 $\kappa$ 直到满足收敛条件。
本质是采用原始对偶内点法对求解过程的适配。

### Siconos
与IPC和Primal-Dual将刚体的非平滑约束转化为平滑约束的思路不同，Siconos求解器采用的是非平滑牛顿求解器，直接将刚体接触和摩擦的动力学方程转化为混合互补问题（MCP，LCP的变种），这些约束本身存在导数跳变，无法用针对平滑方程的牛顿求解器来优化，但可通过以下两种方法进行转化：
- 互补函数，比如法向约束可转化为：
  $$\Phi(r_N,u_N)=r_Nu_N+\epsilon ln(1+r_N^2+u_N^2)=0$$
  其中 $\epsilon$ 是正则化参数，使函数在原点附近平滑化
- 克拉克次梯度：对于非平滑函数，计算其导数跳变点的克拉克次梯度（所有可能的导数的集合），构建次梯度矩阵，将牛顿迭代的搜索方向定义为次梯度的解
与IPC通过接触势能、Primal-Dual通过障碍函数对约束进行平滑化的思路不同，以上两种方法都是在数值层面解决非平滑因素。
  
### ABD
ABD采用IPC框架，但把刚体的完全刚性约束放松为仿射约束，传统刚体有6个自由度（3个平移+3个旋转），而每个仿射体有12个自由度（3个平移+3x3仿射矩阵）
- 改进点：原IPC中旋转正交性被作为投影牛顿法的可行域条件，导致数值收敛困难，仿射矩阵的本质是放松了旋转矩阵的完全正交性要求，将其作为约束条件引入优化过程，从而避免了完全刚性导致的数值难题。
- 直观理解：就是在IPC的势能项里加了个正交势能项。

### VBD/AVBD
VBD可以看作是能量最小化的GS迭代形式，将整个刚体系统分解为逐顶点求解，提高计算效率。由于GS迭代的性质，系统整体也可以达到类似隐式欧拉的无条件稳定和收敛性。
AVBD相比于VBD的改进和XPBD之于PBD类似，都是在原有目标函数的基础上增加拉格朗日乘子，用“虚拟约束力”替代绝对刚度，避免数值震荡问题。

### 对比总结
| 对比维度 | XPBD | IPC | ABD | AVBD |
|---|---|---|---|---|
| **定位** | 实时轻量刚体/柔体统一仿真，适用于游戏/VR | 高精度无穿透仿真，适用于 fabrication/机器人 | 高效无穿透 stiff 体仿真，平衡精度与速度 | 实时高鲁棒性仿真，解决 VBD 硬约束与高刚度比时失真的问题 |
| **求解框架** | GS迭代，位置直接更新 | 增量势能接触（IPC）+ 牛顿法，轨迹无穿透保证 | 仿射变换松弛刚性约束，IPC 接触模型+线性 CCD | 混合 Primal-Dual 方法，VBD 顶点级迭代+增广拉格朗日，硬约束渐进刚度提升                                   |
| **优势** | 1. 速度快，单线程 1-600ms/帧（16-560 刚体）；<br>2. 支持关节/摩擦，参数少易实现；<br>3. 无条件稳定，支持大时间步 | 1. 唯一严格无穿透保证，轨迹全局安全；<br>2. 无需参数调优，适配复杂机械结构（如齿轮/锁箱）；<br>3. 支持余维物体（点云/线框） | 1. 线性 CCD 替代弯曲 CCD，比 IPC 快 100-10000×；<br>2. 无穿透保证，支持 GPU 交互速率（5-10 FPS）；<br>3. 直接处理原始网格，无需凸分解 | 1. 支持硬约束/高刚度比（10000:1）/高质量比（50000:1）；<br>2. 速度最快，RTX4090 3.5-10.3ms/帧（11万-51万刚体）；<br>3. 无需参数调优，兼容关节/摩擦/堆叠                                  |
| **劣势** | 1. 高质量比（>1000:1）易拉伸崩溃；<br>2. 无严格无穿透保证，大时间步易穿透；<br>3. 硬约束依赖软刚度近似，精度有限 | 1. 弯曲 CCD 昂贵，速度慢（比 ABD 慢 100-1000×）；<br>2. 大规模场景（>1 万刚体）难以实时；<br>3. 不支持关节约束直接建模 | 1. 仿射变换引入微小形变，严格刚体场景有偏差；<br>2. 关节约束需线性化处理，复杂度高于 AVBD；<br>3. 求解器依赖 Newton 法，小场景开销略高 | 1. 无严格无穿透保证（依赖碰撞检测）；<br>2. 长链机构信息传播依赖迭代次数；<br>3. 数值耗散（隐式欧拉），高频振动需阻尼补偿 |
| **性能** | 单线程 1.5ms（16 刚体）- 809ms（560 刚体）；<br>依赖子步提升精度（26 子步仍可能崩溃） | CPU 多线程 0.004-310s/帧（2-27645 刚体）；<br>复杂场景（齿轮）需数小时/帧 | CPU 12s/帧（28 齿轮）- GPU 5-10 FPS（复杂接触）；<br>比 IPC 快 124-10000× | RTX4090 3.5ms（11 万刚体）-10.3ms（51 万刚体）；<br>迭代次数少（3-4 次即可稳定） |
